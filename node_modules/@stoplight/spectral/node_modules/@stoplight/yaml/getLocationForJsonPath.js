"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yaml_ast_parser_1 = require("yaml-ast-parser");
const lineForPosition_1 = require("./lineForPosition");
exports.getLocationForJsonPath = ({ ast, lineMap }, path, closest = false) => {
    const node = findNodeAtPath(ast, path, closest);
    if (node === void 0)
        return;
    return getLoc(lineMap, {
        start: getStartPosition(node, lineMap.length > 0 ? lineMap[0] : 0),
        end: getEndPosition(node),
    });
};
function getStartPosition(node, offset) {
    if (node.parent && node.parent.kind === yaml_ast_parser_1.Kind.MAPPING) {
        if (node.parent.value === null) {
            return node.parent.endPosition;
        }
        if (node.kind !== yaml_ast_parser_1.Kind.SCALAR) {
            return node.parent.key.endPosition + 1;
        }
    }
    if (node.parent === null && offset - node.startPosition === 0) {
        return 0;
    }
    return node.startPosition;
}
function getEndPosition(node) {
    switch (node.kind) {
        case yaml_ast_parser_1.Kind.SEQ:
            const { items } = node;
            if (items.length !== 0 && items[items.length - 1] !== null) {
                return getEndPosition(items[items.length - 1]);
            }
            break;
        case yaml_ast_parser_1.Kind.MAPPING:
            if (node.value !== null) {
                return getEndPosition(node.value);
            }
            break;
        case yaml_ast_parser_1.Kind.MAP:
            if (node.value !== null && node.mappings.length !== 0) {
                return getEndPosition(node.mappings[node.mappings.length - 1]);
            }
            break;
        case yaml_ast_parser_1.Kind.SCALAR:
            if (node.parent !== null && node.parent.kind === yaml_ast_parser_1.Kind.MAPPING && node.parent.value === null) {
                return node.parent.endPosition;
            }
            break;
    }
    return node.endPosition;
}
function findNodeAtPath(node, path, closest) {
    pathLoop: for (const segment of path) {
        switch (node && node.kind) {
            case yaml_ast_parser_1.Kind.MAP:
                for (const item of node.mappings) {
                    if (item.key.value === segment) {
                        if (item.value === null) {
                            node = item.key;
                        }
                        else {
                            node = item.value;
                        }
                        continue pathLoop;
                    }
                }
                return closest ? node : void 0;
            case yaml_ast_parser_1.Kind.SEQ:
                for (let i = 0; i < node.items.length; i++) {
                    if (i === Number(segment)) {
                        node = node.items[i];
                        continue pathLoop;
                    }
                }
                return closest ? node : void 0;
            default:
                return closest ? node : void 0;
        }
    }
    return node;
}
const getLoc = (lineMap, { start = 0, end = 0 }) => {
    const startLine = lineForPosition_1.lineForPosition(start, lineMap);
    const endLine = lineForPosition_1.lineForPosition(end, lineMap);
    return {
        range: {
            start: {
                line: startLine,
                character: start - (startLine === 0 ? 0 : lineMap[startLine - 1]),
            },
            end: {
                line: endLine,
                character: end - (endLine === 0 ? 0 : lineMap[endLine - 1]),
            },
        },
    };
};
//# sourceMappingURL=getLocationForJsonPath.js.map