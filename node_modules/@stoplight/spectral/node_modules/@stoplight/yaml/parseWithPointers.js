"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@stoplight/types");
const yaml_ast_parser_1 = require("yaml-ast-parser");
const buildJsonPath_1 = require("./buildJsonPath");
const lineForPosition_1 = require("./lineForPosition");
exports.parseWithPointers = (value, options) => {
    const lineMap = computeLineMap(value);
    const ast = yaml_ast_parser_1.load(value, Object.assign({}, options, { ignoreDuplicateKeys: true }));
    const parsed = {
        ast,
        lineMap,
        data: {},
        diagnostics: [],
    };
    if (!ast)
        return parsed;
    const duplicatedMappingKeys = [];
    parsed.data = exports.walkAST(ast, options !== undefined && options.ignoreDuplicateKeys === false ? duplicatedMappingKeys : undefined);
    if (duplicatedMappingKeys.length > 0) {
        parsed.diagnostics.push(...transformDuplicatedMappingKeys(duplicatedMappingKeys, lineMap));
    }
    if (ast.errors) {
        parsed.diagnostics.push(...transformErrors(ast.errors, lineMap));
    }
    if (parsed.diagnostics.length > 0) {
        parsed.diagnostics.sort((itemA, itemB) => itemA.range.start.line - itemB.range.start.line);
    }
    return parsed;
};
exports.walkAST = (node, duplicatedMappingKeys) => {
    if (node) {
        switch (node.kind) {
            case yaml_ast_parser_1.Kind.MAP: {
                const container = {};
                for (const mapping of node.mappings) {
                    if (duplicatedMappingKeys !== undefined && mapping.key.value in container) {
                        duplicatedMappingKeys.push(mapping.key);
                    }
                    container[mapping.key.value] = exports.walkAST(mapping.value, duplicatedMappingKeys);
                }
                return container;
            }
            case yaml_ast_parser_1.Kind.SEQ:
                return node.items.map(item => exports.walkAST(item, duplicatedMappingKeys));
            case yaml_ast_parser_1.Kind.SCALAR:
                return 'valueObject' in node ? node.valueObject : node.value;
            case yaml_ast_parser_1.Kind.ANCHOR_REF:
                if (node.value !== void 0 && isCircularAnchorRef(node)) {
                    node.value = dereferenceAnchor(node.value, node.referencesAnchor);
                }
                return exports.walkAST(node.value, duplicatedMappingKeys);
            default:
                return null;
        }
    }
    return node;
};
const isCircularAnchorRef = (anchorRef) => {
    const { referencesAnchor } = anchorRef;
    let node = anchorRef;
    while ((node = node.parent)) {
        if ('anchorId' in node && node.anchorId === referencesAnchor) {
            return true;
        }
    }
    return false;
};
const dereferenceAnchor = (node, anchorId) => {
    if (!node)
        return node;
    if ('referencesAnchor' in node && node.referencesAnchor === anchorId)
        return;
    switch (node.kind) {
        case yaml_ast_parser_1.Kind.MAP:
            return Object.assign({}, node, { mappings: node.mappings.map(mapping => dereferenceAnchor(mapping, anchorId)) });
        case yaml_ast_parser_1.Kind.SEQ:
            return Object.assign({}, node, { items: node.items.map(item => dereferenceAnchor(item, anchorId)) });
        case yaml_ast_parser_1.Kind.MAPPING:
            return Object.assign({}, node, { value: dereferenceAnchor(node.value, anchorId) });
        case yaml_ast_parser_1.Kind.SCALAR:
            return node;
        case yaml_ast_parser_1.Kind.ANCHOR_REF:
            if (node.value !== undefined && isCircularAnchorRef(node)) {
                return;
            }
            return node;
        default:
            return node;
    }
};
const computeLineMap = (input) => {
    const lines = input.split(/\n/);
    const lineMap = [];
    let sum = 0;
    for (const line of lines) {
        sum += line.length + 1;
        lineMap.push(sum);
    }
    return lineMap;
};
function getLineLength(lineMap, line) {
    if (line === 0) {
        return Math.max(0, lineMap[0] - 1);
    }
    return Math.max(0, lineMap[line] - lineMap[line - 1] - 1);
}
const transformErrors = (errors, lineMap) => {
    const validations = [];
    for (const error of errors) {
        const validation = {
            code: error.name,
            message: error.reason,
            severity: error.isWarning ? types_1.DiagnosticSeverity.Warning : types_1.DiagnosticSeverity.Error,
            range: {
                start: {
                    line: error.mark.line,
                    character: error.mark.column,
                },
                end: {
                    line: error.mark.line,
                    character: error.mark.toLineEnd ? getLineLength(lineMap, error.mark.line) : error.mark.column,
                },
            },
        };
        validations.push(validation);
    }
    return validations;
};
const transformDuplicatedMappingKeys = (nodes, lineMap) => {
    const validations = [];
    for (const node of nodes) {
        const startLine = lineForPosition_1.lineForPosition(node.startPosition, lineMap);
        const endLine = lineForPosition_1.lineForPosition(node.endPosition, lineMap);
        validations.push({
            code: 'YAMLException',
            message: 'duplicate key',
            path: buildJsonPath_1.buildJsonPath(node),
            range: {
                start: {
                    line: startLine,
                    character: startLine === 0 ? node.startPosition : node.startPosition - lineMap[startLine - 1],
                },
                end: {
                    line: endLine,
                    character: endLine === 0 ? node.endPosition : node.endPosition - lineMap[endLine - 1],
                },
            },
            severity: types_1.DiagnosticSeverity.Error,
        });
    }
    return validations;
};
//# sourceMappingURL=parseWithPointers.js.map