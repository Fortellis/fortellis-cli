import { Dictionary } from '@stoplight/types';
import { IRulesetReadOptions } from './rulesets/reader';
import { FormatLookup, FunctionCollection, IConstructorOpts, IParsedResult, IRuleResult, IRunOpts, ISpectralFullResult, PartialRuleCollection, RegisteredFormats, RuleCollection, RunRuleCollection } from './types';
import { IRuleset } from './types/ruleset';
export * from './types';
export declare class Spectral {
    private readonly _resolver;
    private readonly _parsedMap;
    private static readonly _parsedCache;
    functions: FunctionCollection;
    rules: RunRuleCollection;
    formats: RegisteredFormats;
    constructor(opts?: IConstructorOpts);
    runWithResolved(target: IParsedResult | object | string, opts?: IRunOpts): Promise<ISpectralFullResult>;
    run(target: IParsedResult | object | string, opts?: IRunOpts): Promise<IRuleResult[]>;
    addFunctions(functions: FunctionCollection): void;
    _addFunctions(functions: FunctionCollection): void;
    setFunctions(functions: FunctionCollection): void;
    addRules(rules: RuleCollection): void;
    setRules(rules: RuleCollection): void;
    private _addRules;
    mergeRules(rules: PartialRuleCollection): void;
    loadRuleset(uris: string[] | string, options?: IRulesetReadOptions): Promise<void>;
    setRuleset(ruleset: IRuleset): void;
    registerFormat(format: string, fn: FormatLookup): void;
    private _processExternalRef;
    private _parseResolveResult;
}
export declare const REF_METADATA: unique symbol;
export declare const isParsedResult: (obj: any) => obj is IParsedResult<import("@stoplight/types").IParserResult<unknown, any, any, any>>;
export interface IParseMap {
    refs: Dictionary<object>;
    parsed: Dictionary<IParsedResult>;
    pointers: Dictionary<string[]>;
}
