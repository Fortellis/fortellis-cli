"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const yargs_1 = require("yargs");
const lodash_1 = require("lodash");
const severity_1 = require("../../rulesets/severity");
const config_1 = require("../../types/config");
const linter_1 = require("../services/linter");
const output_1 = require("../services/output");
const toArray = (args) => (Array.isArray(args) ? args : [args]);
const formatOptions = Object.values(config_1.OutputFormat);
const lintCommand = {
    describe: 'lint JSON/YAML documents from files or URLs',
    command: 'lint <documents..>',
    builder: yargs => yargs
        .positional('documents', {
        description: 'Location of JSON/YAML documents. Can be either a file, a glob or fetchable resource(s) on the web.',
        type: 'string',
    })
        .fail(() => {
        yargs_1.showHelp();
    })
        .check((argv) => {
        if (argv.format !== void 0 && !formatOptions.includes(String(argv.format))) {
            return false;
        }
        return true;
    })
        .options({
        encoding: {
            alias: 'e',
            description: 'text encoding to use',
            type: 'string',
            default: 'utf8',
        },
        format: {
            alias: 'f',
            description: 'formatter to use for outputting results',
            options: formatOptions,
            default: config_1.OutputFormat.STYLISH,
            type: 'string',
        },
        output: {
            alias: 'o',
            description: 'output to a file instead of stdout',
            type: 'string',
        },
        ruleset: {
            alias: 'r',
            description: 'path/URL to a ruleset file',
            type: 'string',
            coerce: toArray,
        },
        'skip-rule': {
            alias: 's',
            description: 'ignore certain rules if they are causing trouble',
            type: 'string',
            coerce: toArray,
        },
        'fail-severity': {
            alias: 'F',
            description: 'results of this level or above will trigger a failure exit code',
            choices: ['error', 'warn', 'info', 'hint'],
            default: 'hint',
            type: 'string',
        },
        'display-only-failures': {
            alias: 'D',
            description: 'only output results equal to or greater than --fail-severity',
            type: 'boolean',
            default: false,
        },
        verbose: {
            alias: 'v',
            description: 'increase verbosity',
            type: 'boolean',
        },
        quiet: {
            alias: 'q',
            description: 'no logging - output only',
            type: 'boolean',
        },
    }),
    handler: args => {
        const _a = args, { documents, failSeverity, displayOnlyFailures, ruleset, format, output, encoding } = _a, config = tslib_1.__rest(_a, ["documents", "failSeverity", "displayOnlyFailures", "ruleset", "format", "output", "encoding"]);
        return linter_1.lint(documents, Object.assign({ format, output, encoding, ruleset }, lodash_1.pick(config, ['skipRule', 'verbose', 'quiet'])))
            .then(results => {
            if (displayOnlyFailures) {
                return filterResultsBySeverity(results, failSeverity);
            }
            return results;
        })
            .then(results => {
            if (results.length) {
                process.exitCode = severeEnoughToFail(results, failSeverity) ? 1 : 0;
            }
            else if (!config.quiet) {
                console.log(`No results with a severity of '${failSeverity}' or higher found!`);
            }
            const formattedOutput = output_1.formatOutput(results, format);
            return output_1.writeOutput(formattedOutput, output);
        })
            .catch(fail);
    },
};
const fail = (err) => {
    console.error(err);
    process.exitCode = 2;
};
const filterResultsBySeverity = (results, failSeverity) => {
    const diagnosticSeverity = severity_1.getDiagnosticSeverity(failSeverity);
    return results.filter(r => r.severity <= diagnosticSeverity);
};
const severeEnoughToFail = (results, failSeverity) => {
    const diagnosticSeverity = severity_1.getDiagnosticSeverity(failSeverity);
    return results.some(r => r.severity <= diagnosticSeverity);
};
exports.default = lintCommand;
//# sourceMappingURL=lint.js.map