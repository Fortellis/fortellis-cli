"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const yaml_1 = require("@stoplight/yaml");
const formats_1 = require("../../../formats");
const reader_1 = require("../../../fs/reader");
const http_and_file_1 = require("../../../resolvers/http-and-file");
const runner_1 = require("../../../runner");
const spectral_1 = require("../../../spectral");
const utils_1 = require("./utils");
const KNOWN_FORMATS = [
    ['oas2', formats_1.isOpenApiv2, 'OpenAPI 2.0 (Swagger) detected'],
    ['oas3', formats_1.isOpenApiv3, 'OpenAPI 3.x detected'],
    ['json-schema', formats_1.isJSONSchema, 'JSON Schema detected'],
    ['json-schema-loose', formats_1.isJSONSchemaLoose, 'JSON Schema (loose) detected'],
    ['json-schema-draft4', formats_1.isJSONSchemaDraft4, 'JSON Schema Draft 4 detected'],
    ['json-schema-draft6', formats_1.isJSONSchemaDraft6, 'JSON Schema Draft 6 detected'],
    ['json-schema-draft7', formats_1.isJSONSchemaDraft7, 'JSON Schema Draft 7 detected'],
    ['json-schema-2019-09', formats_1.isJSONSchemaDraft2019_09, 'JSON Schema Draft 2019-09 detected'],
];
function lint(documents, flags) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const spectral = new spectral_1.Spectral({ resolver: http_and_file_1.httpAndFileResolver });
        const ruleset = yield utils_1.getRuleset(flags.ruleset);
        spectral.setRuleset(ruleset);
        for (const [format, lookup, message] of KNOWN_FORMATS) {
            spectral.registerFormat(format, document => {
                if (lookup(document)) {
                    if (!flags.quiet) {
                        console.log(message);
                    }
                    return true;
                }
                return false;
            });
        }
        if (flags.verbose) {
            if (ruleset) {
                const rules = Object.values(spectral.rules);
                console.info(`Found ${rules.length} rules (${rules.filter(runner_1.isRuleEnabled).length} enabled)`);
            }
            else {
                console.info('No rules loaded, attempting to detect document type');
            }
        }
        if (flags.skipRule) {
            spectral.setRules(utils_1.skipRules(ruleset.rules, flags));
        }
        const targetUris = yield utils_1.listFiles(documents);
        const results = [];
        for (const targetUri of targetUris) {
            if (flags.verbose) {
                console.info(`Linting ${targetUri}`);
            }
            const spec = yaml_1.parseWithPointers(yield reader_1.readParsable(targetUri, { encoding: flags.encoding }), {
                ignoreDuplicateKeys: false,
                mergeKeys: true,
            });
            const parsedResult = {
                source: targetUri,
                parsed: spec,
                getLocationForJsonPath: yaml_1.getLocationForJsonPath,
            };
            results.push(...(yield spectral.run(parsedResult, {
                resolve: {
                    documentUri: targetUri,
                },
            })));
        }
        return results;
    });
}
exports.lint = lint;
//# sourceMappingURL=linter.js.map