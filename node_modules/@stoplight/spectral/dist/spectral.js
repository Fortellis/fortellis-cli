"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_1 = require("@stoplight/json");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const path_1 = require("@stoplight/path");
const yaml_1 = require("@stoplight/yaml");
const lodash_1 = require("lodash");
const deprecated_decorator_1 = require("deprecated-decorator");
const error_messages_1 = require("./error-messages");
const functions_1 = require("./functions");
const resolved_1 = require("./resolved");
const rulesets_1 = require("./rulesets");
const evaluators_1 = require("./rulesets/evaluators");
const severity_1 = require("./rulesets/severity");
const runner_1 = require("./runner");
tslib_1.__exportStar(require("./types"), exports);
class Spectral {
    constructor(opts) {
        this.functions = Object.assign({}, functions_1.functions);
        this.rules = {};
        this._parseResolveResult = (refDiagnostics) => (resolveOpts) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ref = resolveOpts.targetAuthority.toString();
            const ext = path_1.extname(ref);
            const content = String(resolveOpts.result);
            let parsedRefResult;
            if (ext === '.yml' || ext === '.yaml') {
                parsedRefResult = {
                    parsed: yaml_1.parseWithPointers(content, { ignoreDuplicateKeys: false }),
                    source: ref,
                    getLocationForJsonPath: yaml_1.getLocationForJsonPath,
                };
            }
            else if (ext === '.json') {
                parsedRefResult = {
                    parsed: json_1.parseWithPointers(content, { ignoreDuplicateKeys: false }),
                    source: ref,
                    getLocationForJsonPath: json_1.getLocationForJsonPath,
                };
            }
            if (parsedRefResult !== undefined) {
                resolveOpts.result = parsedRefResult.parsed.data;
                if (parsedRefResult.parsed.diagnostics.length > 0) {
                    refDiagnostics.push(...error_messages_1.formatParserDiagnostics(parsedRefResult.parsed.diagnostics, parsedRefResult.source));
                }
                this._processExternalRef(parsedRefResult, resolveOpts);
            }
            return resolveOpts;
        });
        this._resolver = opts && opts.resolver ? opts.resolver : new json_ref_resolver_1.Resolver();
        this.formats = {};
        const cacheKey = this._resolver instanceof json_ref_resolver_1.Resolver ? this._resolver.uriCache : this._resolver;
        const _parsedMap = Spectral._parsedCache.get(cacheKey);
        if (_parsedMap) {
            this._parsedMap = _parsedMap;
        }
        else {
            this._parsedMap = {
                refs: {},
                parsed: {},
                pointers: {},
            };
            Spectral._parsedCache.set(cacheKey, this._parsedMap);
        }
    }
    runWithResolved(target, opts = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let results = [];
            let parsedResult;
            if (!exports.isParsedResult(target)) {
                parsedResult = {
                    parsed: yaml_1.parseWithPointers(typeof target === 'string' ? target : json_1.safeStringify(target, undefined, 2), {
                        ignoreDuplicateKeys: false,
                        mergeKeys: true,
                    }),
                    getLocationForJsonPath: yaml_1.getLocationForJsonPath,
                };
            }
            else {
                parsedResult = target;
            }
            results = results.concat(error_messages_1.formatParserDiagnostics(parsedResult.parsed.diagnostics, parsedResult.source));
            const documentUri = opts.resolve && opts.resolve.documentUri;
            const refDiagnostics = [];
            const resolved = new resolved_1.Resolved(parsedResult, yield this._resolver.resolve(parsedResult.parsed.data, {
                baseUri: documentUri,
                parseResolveResult: this._parseResolveResult(refDiagnostics),
            }), this._parsedMap);
            if (resolved.formats === void 0) {
                const foundFormats = Object.keys(this.formats).filter(format => this.formats[format](resolved.resolved));
                resolved.formats = foundFormats.length === 0 ? null : foundFormats;
            }
            const validationResults = [
                ...refDiagnostics,
                ...results,
                ...error_messages_1.formatResolverErrors(resolved),
                ...runner_1.runRules(resolved, this.rules, this.functions),
            ];
            return {
                resolved: resolved.resolved,
                results: validationResults,
            };
        });
    }
    run(target, opts = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.runWithResolved(target, opts)).results;
        });
    }
    addFunctions(functions) {
        this._addFunctions(functions);
    }
    _addFunctions(functions) {
        Object.assign(this.functions, functions);
    }
    setFunctions(functions) {
        for (const key in this.functions) {
            if (!Object.hasOwnProperty.call(this.functions, key))
                continue;
            delete this.functions[key];
        }
        this._addFunctions(Object.assign(Object.assign({}, functions_1.functions), functions));
    }
    addRules(rules) {
        this._addRules(rules);
    }
    setRules(rules) {
        for (const key in this.rules) {
            if (!Object.hasOwnProperty.call(this.rules, key))
                continue;
            delete this.rules[key];
        }
        this._addRules(Object.assign({}, rules));
    }
    _addRules(rules) {
        for (const name in rules) {
            if (!rules.hasOwnProperty(name))
                continue;
            const rule = rules[name];
            this.rules[name] = Object.assign(Object.assign({ name }, rule), { severity: rule.severity === void 0 ? severity_1.DEFAULT_SEVERITY_LEVEL : severity_1.getDiagnosticSeverity(rule.severity) });
        }
    }
    mergeRules(rules) {
        for (const name in rules) {
            if (!rules.hasOwnProperty(name))
                continue;
            const rule = rules[name];
            if (rule) {
                this.rules[name] = lodash_1.merge(this.rules[name], rule);
            }
        }
    }
    loadRuleset(uris, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.setRuleset(yield rulesets_1.readRuleset(Array.isArray(uris) ? uris : [uris], options));
        });
    }
    setRuleset(ruleset) {
        this.setRules(ruleset.rules);
        this.setFunctions(Object.entries(ruleset.functions).reduce((fns, [key, { code, ref, name, schema }]) => {
            if (code === void 0) {
                if (ref !== void 0) {
                    ({ code } = ruleset.functions[ref]);
                }
            }
            if (code === void 0) {
                return fns;
            }
            fns[key] = evaluators_1.compileExportedFunction(code, name, schema);
            return fns;
        }, Object.assign({}, functions_1.functions)));
    }
    registerFormat(format, fn) {
        this.formats[format] = fn;
    }
    _processExternalRef(parsedResult, opts) {
        const ref = opts.targetAuthority.toString();
        this._parsedMap.parsed[ref] = parsedResult;
        this._parsedMap.pointers[ref] = opts.parentPath;
        const parentRef = opts.parentAuthority.toString();
        lodash_1.set(this._parsedMap.refs, [...(this._parsedMap.pointers[parentRef] ? this._parsedMap.pointers[parentRef] : []), ...opts.parentPath], Object.defineProperty({}, exports.REF_METADATA, {
            enumerable: false,
            writable: false,
            value: {
                ref,
                root: opts.fragment.split('/').slice(1),
            },
        }));
    }
}
Spectral._parsedCache = new WeakMap();
tslib_1.__decorate([
    deprecated_decorator_1.default('loadRuleset', '4.1'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], Spectral.prototype, "addFunctions", null);
tslib_1.__decorate([
    deprecated_decorator_1.default('loadRuleset', '4.1'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], Spectral.prototype, "addRules", null);
exports.Spectral = Spectral;
exports.REF_METADATA = Symbol('external_ref_metadata');
exports.isParsedResult = (obj) => {
    if (!obj || typeof obj !== 'object')
        return false;
    if (!obj.parsed || typeof obj.parsed !== 'object')
        return false;
    if (!obj.getLocationForJsonPath || typeof obj.getLocationForJsonPath !== 'function')
        return false;
    return true;
};
//# sourceMappingURL=spectral.js.map