"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { JSONPath } = require('jsonpath-plus');
const linter_1 = require("./linter");
const severity_1 = require("./rulesets/severity");
const utils_1 = require("./utils/");
exports.isRuleEnabled = (rule) => rule.severity !== void 0 && severity_1.getDiagnosticSeverity(rule.severity) !== -1;
exports.runRules = (resolved, rules, functions) => {
    let results = [];
    for (const name in rules) {
        if (!rules.hasOwnProperty(name))
            continue;
        const rule = rules[name];
        if (!rule)
            continue;
        if (rule.formats !== void 0 &&
            (resolved.formats === null ||
                (resolved.formats !== void 0 && !utils_1.hasIntersectingElement(rule.formats, resolved.formats))))
            continue;
        if (!exports.isRuleEnabled(rule)) {
            continue;
        }
        try {
            results = results.concat(runRule(resolved, rule, functions));
        }
        catch (e) {
            console.error(`Unable to run rule '${name}':\n${e}`);
        }
    }
    return results;
};
const runRule = (resolved, rule, functions) => {
    const target = rule.resolved === false ? resolved.unresolved : resolved.resolved;
    const results = [];
    const nodes = [];
    if (rule.given && rule.given !== '$') {
        try {
            JSONPath({
                path: rule.given,
                json: target,
                resultType: 'all',
                callback: (result) => {
                    nodes.push({
                        path: JSONPath.toPathArray(result.path),
                        value: result.value,
                    });
                },
            });
        }
        catch (e) {
            console.error(e);
        }
    }
    else {
        nodes.push({
            path: ['$'],
            value: target,
        });
    }
    for (const node of nodes) {
        try {
            const thens = Array.isArray(rule.then) ? rule.then : [rule.then];
            for (const then of thens) {
                const func = functions[then.function];
                if (!func) {
                    console.warn(`Function ${then.function} not found. Called by rule ${rule.name}.`);
                    continue;
                }
                results.push(...linter_1.lintNode(node, rule, then, func, resolved));
            }
        }
        catch (e) {
            console.warn(`Encountered error when running rule '${rule.name}' on node at path '${node.path}':\n${e}`);
        }
    }
    return results;
};
//# sourceMappingURL=runner.js.map