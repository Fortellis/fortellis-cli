"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const path_1 = require("@stoplight/path");
const yaml_1 = require("@stoplight/yaml");
const reader_1 = require("../fs/reader");
const http_and_file_1 = require("../resolvers/http-and-file");
const finder_1 = require("./finder");
const mergers_1 = require("./mergers");
const validation_1 = require("./validation");
function readRuleset(uris, opts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const base = {
            rules: {},
            functions: {},
        };
        const processedRulesets = new Set();
        const processRuleset = createRulesetProcessor(processedRulesets, new json_ref_resolver_1.Cache(), opts);
        for (const uri of Array.isArray(uris) ? new Set([...uris]) : [uris]) {
            processedRulesets.clear();
            const resolvedRuleset = yield processRuleset(uri, uri);
            if (resolvedRuleset === null)
                continue;
            Object.assign(base.rules, resolvedRuleset.rules);
            Object.assign(base.functions, resolvedRuleset.functions);
        }
        return base;
    });
}
exports.readRuleset = readRuleset;
const createRulesetProcessor = (processedRulesets, uriCache, readOpts) => {
    return function processRuleset(baseUri, uri, severity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rulesetUri = yield finder_1.findFile(path_1.join(baseUri, '..'), uri);
            if (processedRulesets.has(rulesetUri)) {
                return null;
            }
            processedRulesets.add(rulesetUri);
            const { result } = yield http_and_file_1.httpAndFileResolver.resolve(yaml_1.parse(yield reader_1.readParsable(rulesetUri, {
                timeout: readOpts && readOpts.timeout,
                encoding: 'utf8',
            })), {
                baseUri: rulesetUri,
                dereferenceInline: false,
                uriCache,
                parseResolveResult(opts) {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            opts.result = yaml_1.parse(opts.result);
                        }
                        catch (_a) {
                        }
                        return opts;
                    });
                },
            });
            const ruleset = validation_1.assertValidRuleset(JSON.parse(JSON.stringify(result)));
            const rules = {};
            const functions = {};
            const newRuleset = {
                rules,
                functions,
            };
            const extendedRulesets = ruleset.extends;
            const rulesetFunctions = ruleset.functions;
            if (extendedRulesets !== void 0) {
                for (const extended of Array.isArray(extendedRulesets) ? extendedRulesets : [extendedRulesets]) {
                    let extendedRuleset;
                    let parentSeverity;
                    if (Array.isArray(extended)) {
                        parentSeverity = severity === undefined ? extended[1] : severity;
                        extendedRuleset = yield processRuleset(rulesetUri, extended[0], parentSeverity);
                    }
                    else {
                        parentSeverity = severity === undefined ? 'recommended' : severity;
                        extendedRuleset = yield processRuleset(rulesetUri, extended, parentSeverity);
                    }
                    if (extendedRuleset !== null) {
                        mergers_1.mergeRules(rules, extendedRuleset.rules, parentSeverity);
                        Object.assign(functions, extendedRuleset.functions);
                    }
                }
            }
            mergers_1.mergeRules(rules, ruleset.rules, severity === undefined ? 'recommended' : severity);
            if (Array.isArray(ruleset.formats)) {
                mergers_1.mergeFormats(rules, ruleset.formats);
            }
            if (rulesetFunctions !== void 0) {
                const rulesetFunctionsBaseDir = path_1.join(rulesetUri, ruleset.functionsDir !== void 0 ? path_1.join('..', ruleset.functionsDir) : '../functions');
                const resolvedFunctions = {};
                yield Promise.all(rulesetFunctions.map((fn) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const fnName = Array.isArray(fn) ? fn[0] : fn;
                    const fnSchema = Array.isArray(fn) ? fn[1] : null;
                    try {
                        resolvedFunctions[fnName] = {
                            name: fnName,
                            code: yield reader_1.readFile(yield finder_1.findFile(rulesetFunctionsBaseDir, `./${fnName}.js`), {
                                timeout: readOpts && readOpts.timeout,
                                encoding: 'utf8',
                            }),
                            schema: fnSchema,
                        };
                    }
                    catch (ex) {
                        console.warn(`Function '${fnName}' could not be loaded: ${ex.message}`);
                    }
                })));
                mergers_1.mergeFunctions(functions, resolvedFunctions, rules);
            }
            return newRuleset;
        });
    };
};
//# sourceMappingURL=reader.js.map