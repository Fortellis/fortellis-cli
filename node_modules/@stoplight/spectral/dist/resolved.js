"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_1 = require("@stoplight/json");
const lodash_1 = require("lodash");
const spectral_1 = require("./spectral");
const utils_1 = require("./utils");
const getDefaultRange = () => ({
    start: {
        line: 0,
        character: 0,
    },
    end: {
        line: 0,
        character: 0,
    },
});
class Resolved {
    constructor(spec, resolveResult, parsedMap) {
        this.spec = spec;
        this.parsedMap = parsedMap;
        this.unresolved = spec.parsed.data;
        this.formats = spec.formats;
        this.refMap = resolveResult.refMap;
        this.resolved = resolveResult.result;
        this.errors = resolveResult.errors;
    }
    doesBelongToDoc(path) {
        if (path.length === 0) {
            return true;
        }
        let piece = this.unresolved;
        for (let i = 0; i < path.length; i++) {
            if (!utils_1.isObject(piece))
                return false;
            if (path[i] in piece) {
                piece = piece[path[i]];
            }
            else if (utils_1.hasRef(piece)) {
                return this.doesBelongToDoc([...json_1.pointerToPath(piece.$ref), ...path.slice(i)]);
            }
        }
        return true;
    }
    getParsedForJsonPath(path) {
        let target = this.parsedMap.refs;
        const newPath = [...path];
        let segment;
        while (newPath.length > 0) {
            segment = newPath.shift();
            if (segment && segment in target) {
                target = target[segment];
            }
            else {
                newPath.unshift(segment);
                break;
            }
        }
        if (target && target[spectral_1.REF_METADATA]) {
            return {
                path: [...lodash_1.get(target, [spectral_1.REF_METADATA, 'root'], []).map(json_1.decodePointerFragment), ...newPath],
                doc: lodash_1.get(this.parsedMap.parsed, lodash_1.get(target, [spectral_1.REF_METADATA, 'ref']), this.spec),
            };
        }
        if (!this.doesBelongToDoc(path)) {
            return null;
        }
        return {
            path,
            doc: this.spec,
        };
    }
    getLocationForJsonPath(path, closest) {
        const parsedResult = this.getParsedForJsonPath(path);
        if (parsedResult === null) {
            return {
                range: getDefaultRange(),
            };
        }
        const location = parsedResult.doc.getLocationForJsonPath(parsedResult.doc.parsed, parsedResult.path, closest);
        return Object.assign(Object.assign({}, (parsedResult.doc.source && { uri: parsedResult.doc.source })), { range: location !== void 0 ? location.range : getDefaultRange() });
    }
    getValueForJsonPath(path) {
        const parsedResult = this.getParsedForJsonPath(path);
        return parsedResult === null ? void 0 : lodash_1.get(parsedResult.doc.parsed.data, parsedResult.path);
    }
}
exports.Resolved = Resolved;
//# sourceMappingURL=resolved.js.map