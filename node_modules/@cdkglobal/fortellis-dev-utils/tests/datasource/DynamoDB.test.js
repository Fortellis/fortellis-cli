const DynamoDB = require('../../src/datasource/DynamoDB');

jest.mock('aws-sdk');

describe('DynamoDB datasource utility', () => {
  describe('Error Handling', () => {
    test('Should respond normally if Dynamo throws no error', async () => {
      const res = await DynamoDB.scan({
        TableName: 'test',
        resolve: [{ name: 'test' }]
      });
      expect(res).toBeDefined();
      expect(res).toHaveLength(1);
      expect(res[0].name).toEqual('test');
    });

    test('Should throw correct error for "AccessDeniedException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'AccessDeniedException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ConditionalCheckFailedException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ConditionalCheckFailedException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "IncompleteSignatureException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'IncompleteSignatureException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ItemCollectionSizeLimitExceededException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ItemCollectionSizeLimitExceededException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "MissingAuthenticationTokenException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'MissingAuthenticationTokenException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "LimitExceededException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'LimitExceededException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ResourceInUseException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ResourceInUseException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ResourceNotFoundException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ResourceNotFoundException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ThrottlingException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ThrottlingException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "RequestLimitExceeded"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'RequestLimitExceeded',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "UnrecognizedClientException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'UnrecognizedClientException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ValidationException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ValidationException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(500);
      expect(finalError.message).toEqual('Internal Server Error.');
    });

    test('Should throw correct error for "ProvisionedThroughputExceededException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'ProvisionedThroughputExceededException',
            statusCode: 400
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(429);
      expect(finalError.message).toEqual('Too Many Requests.');
    });

    test('Should throw correct error for "ProvisionedThroughputExceededException"', async () => {
      let finalError;
      try {
        await DynamoDB.scan({
          TableName: 'test',
          reject: {
            code: 'DynamoFailedException',
            statusCode: 500
          }
        });
      } catch (err) {
        finalError = err;
      }

      expect(finalError.httpCode).toBe(503);
      expect(finalError.message).toEqual('Service Unavaliable. Please Retry.');
    });
  });
});
