const entitlementsProcessor = require('../../src/middleware/entitlementsProcessor');
// mocks
const TEST_RESOURCE = 'test_resource';
const TEST_ACTION = 'test_action';
const TEST_ENTITY = 'test_entity';
const TEST_USERNAME = 'test_username';
const TEST_UID = 'test_uid';
const DEFAULT_ERROR =
  'You do not have permission to perform actions on this resource.';
const NEXT_MOCK = jest.fn();
const RES_MOCK = {
  json: jest.fn(),
  status: jest.fn()
};
const REQ_MOCK = {
  apiGateway: {
    event: {
      requestContext: {
        authorizer: {
          entityId: '',
          entitlements: '',
          uid: '',
          username: ''
        }
      }
    }
  }
};
const PERMISSION_MOCK = {
  resource: TEST_RESOURCE,
  action: TEST_ACTION
};

describe('Entitlements Processor', () => {
  let req = REQ_MOCK;
  let res = RES_MOCK;
  let next = NEXT_MOCK;

  function setEntityId(entityId) {
    req.apiGateway.event.requestContext.authorizer.entityId = entityId;
  }

  function setUsername(username) {
    req.apiGateway.event.requestContext.authorizer.username = username;
  }

  function setUid(uid) {
    req.apiGateway.event.requestContext.authorizer.uid = uid;
  }

  function setEntitlements(entitlements) {
    for (let resource of Object.keys(entitlements)) {
      entitlements[resource] = JSON.stringify(entitlements[resource]);
    }
    req.apiGateway.event.requestContext.authorizer.entitlements = JSON.stringify(
      entitlements
    );
  }

  beforeEach(() => {
    jest.clearAllMocks();
    req = REQ_MOCK;
    res = RES_MOCK;
    next = NEXT_MOCK;
  });

  // STANDARD EXISTS/CONTRACT CHECKS
  test('Should exist', () => {
    expect(entitlementsProcessor).toBeDefined();
  });

  test('Should return a function', () => {
    const mw = entitlementsProcessor({}, () => {});
    expect(typeof mw).toBe('function');
  });

  test('Should call findEntityContext parameter with req object', () => {
    const findEntityContext = jest.fn();

    entitlementsProcessor(PERMISSION_MOCK, findEntityContext)(req, res, next);

    expect(findEntityContext).toHaveBeenCalledTimes(1);
    expect(findEntityContext).toHaveBeenCalledWith(req);
  });

  test('Should call findUsername parameter with req object', () => {
    const findUsername = jest.fn();

    entitlementsProcessor(undefined, undefined, findUsername)(req, res, next);

    expect(findUsername).toHaveBeenCalledTimes(1);
    expect(findUsername).toHaveBeenCalledWith(req);
  });

  test('Should call findUid parameter with req object', () => {
    const findUid = jest.fn();

    entitlementsProcessor(undefined, undefined, undefined, findUid)(
      req,
      res,
      next
    );

    expect(findUid).toHaveBeenCalledTimes(1);
    expect(findUid).toHaveBeenCalledWith(req);
  });

  test('Should call all given "find" function parameters with req object when no permission given', async () => {
    const findEntityContext = jest.fn();
    const findUsername = jest.fn();
    const findUid = jest.fn();

    await entitlementsProcessor(
      undefined,
      findEntityContext,
      findUsername,
      findUid
    )(req, res, next);

    expect(findEntityContext).toHaveBeenCalledTimes(1);
    expect(findEntityContext).toHaveBeenCalledWith(req);
    expect(findUsername).toHaveBeenCalledTimes(1);
    expect(findUsername).toHaveBeenCalledWith(req);
    expect(findUid).toHaveBeenCalledTimes(1);
    expect(findUid).toHaveBeenCalledWith(req);
  });

  test('Should reject with 500 if there is failure in processor', async () => {
    const checkEntity = jest.fn().mockRejectedValue('error');
    await entitlementsProcessor(undefined, checkEntity)(req, res, next);

    expect(res.status).toHaveBeenCalledTimes(1);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledTimes(1);
    expect(res.json).toHaveBeenCalledWith('Failed to check user entitlements');
  });

  // PERMISSIONS FLOW
  test('Should allow a token with valid entitlements', async () => {
    setEntityId(TEST_ENTITY);
    setEntitlements({ [TEST_ENTITY]: { [TEST_RESOURCE]: [TEST_ACTION] } });
    await entitlementsProcessor(PERMISSION_MOCK, () => TEST_ENTITY)(
      req,
      res,
      next
    );

    expect(RES_MOCK.json).not.toHaveBeenCalled();
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should allow a token with valid admin entitlements', async () => {
    setEntityId(TEST_ENTITY);
    setEntitlements({
      [TEST_ENTITY]: { [TEST_RESOURCE]: ['bad_action'] },
      '*': { [TEST_RESOURCE]: [TEST_ACTION] }
    });
    await entitlementsProcessor(PERMISSION_MOCK, () => TEST_ENTITY)(
      req,
      res,
      next
    );

    expect(RES_MOCK.json).not.toHaveBeenCalled();
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should reject a token with invalid entitlements', async () => {
    setEntityId(TEST_ENTITY);
    setEntitlements({
      [TEST_ENTITY]: { [TEST_RESOURCE]: ['bad_action'] }
    });
    await entitlementsProcessor(PERMISSION_MOCK, () => TEST_ENTITY)(
      req,
      res,
      next
    );

    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(
      'You do not have the valid entitlements to access this resource.'
    );
  });

  test('Should reject a token with no entitlements', async () => {
    delete req.apiGateway.event.requestContext.authorizer.entitlements;
    setEntityId(TEST_ENTITY);
    await entitlementsProcessor(PERMISSION_MOCK, () => TEST_ENTITY)(
      req,
      res,
      next
    );

    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(
      'You do not have the valid entitlements to access this resource.'
    );
  });

  test('Should reject a token with an invalid entity context', async () => {
    setEntityId('bad_entity');
    setEntitlements({
      bad_entity: { [TEST_RESOURCE]: [TEST_ACTION] }
    });
    await entitlementsProcessor(PERMISSION_MOCK, () => TEST_ENTITY)(
      req,
      res,
      next
    );

    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(
      'You do not have permissions to perform actions on this entity.'
    );
  });

  test('Should reject a request if entityId is undefined', async () => {
    await entitlementsProcessor(PERMISSION_MOCK, () => undefined)(
      req,
      res,
      next
    );
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith('entityId not present in token');
    expect(RES_MOCK.status).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.status).toHaveBeenCalledWith(403);
  });

  // NON-PERMISSIONS-OWNERSHIP FLOW
  test('Should let through a call with no params passed to the function', async () => {
    await entitlementsProcessor()(req, res, next);
    expect(NEXT_MOCK).toHaveBeenCalled();
  });

  // ENTITY ID FLOW
  test('Should allow a token with valid entity context and no permissions required', async () => {
    setEntityId(TEST_ENTITY);
    await entitlementsProcessor(undefined, () => TEST_ENTITY)(req, res, next);

    expect(RES_MOCK.json).not.toHaveBeenCalled();
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should allow a user with the correct entity and no entitlements when no permission required', async () => {
    delete req.apiGateway.event.requestContext.authorizer.entitlements;
    setEntityId(TEST_ENTITY);
    await entitlementsProcessor(undefined, () => TEST_ENTITY)(req, res, next);

    expect(RES_MOCK.json).not.toHaveBeenCalled();
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should reject a token with no entitlements and no entity context', async () => {
    delete req.apiGateway.event.requestContext.authorizer.entitlements;
    delete req.apiGateway.event.requestContext.authorizer.entityId;
    await entitlementsProcessor(undefined, () => TEST_ENTITY)(req, res, next);

    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });

  test("Should deny a call with an entityId that doesn't match token entityId", async () => {
    setEntityId('BAD_ENTITY_ID');
    await entitlementsProcessor(undefined, () => TEST_ENTITY)(req, res, next);
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });

  // USERNAME FLOW
  test("Should deny a call with a username that doesn't match token username", async () => {
    setUsername('BAD_USERNAME');
    await entitlementsProcessor(undefined, undefined, () => TEST_USERNAME)(
      req,
      res,
      next
    );
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });

  test('Should allow a call with a username that matches token username', async () => {
    setUsername(TEST_USERNAME);
    await entitlementsProcessor(undefined, undefined, () => TEST_USERNAME)(
      req,
      res,
      next
    );
    expect(NEXT_MOCK).toHaveBeenCalled();
  });

  // USER ID FLOW
  test('Should deny a call with an invalid uid', async () => {
    setUid('BAD_UID');

    await entitlementsProcessor(
      undefined,
      undefined,
      undefined,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });

  test('Should allow a call with a valid uid', async () => {
    setUid(TEST_UID);

    await entitlementsProcessor(
      undefined,
      undefined,
      undefined,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  // COMBO TESTS
  test('Should allow a request with a valid entityId but invalid uid', async () => {
    setUid('BAD_UID');
    setEntityId(TEST_ENTITY);

    await entitlementsProcessor(
      undefined,
      () => TEST_ENTITY,
      undefined,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should allow a request with a valid uid but invalid entityId and username', async () => {
    setUid(TEST_UID);
    setEntityId('BAD_ENTITY');
    setUsername('BAD_USERNAME');

    await entitlementsProcessor(
      undefined,
      () => TEST_ENTITY,
      () => TEST_USERNAME,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should deny a request with invalid entityId and uid', async () => {
    setUid('BAD_UID');
    setEntityId('BAD_ENTITY');

    await entitlementsProcessor(
      undefined,
      () => TEST_ENTITY,
      undefined,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });

  test('Should allow a request with a valid username and undefined entityId', async () => {
    setUsername(TEST_USERNAME);
    setEntityId(TEST_ENTITY);

    await entitlementsProcessor(
      undefined,
      () => undefined,
      () => TEST_USERNAME
    )(req, res, next);
    expect(NEXT_MOCK).toHaveBeenCalledTimes(1);
  });

  test('Should deny a request with invalid username and uid', async () => {
    setUid('BAD_UID');
    setUsername('BAD_USER');

    await entitlementsProcessor(
      undefined,
      undefined,
      () => TEST_USERNAME,
      () => TEST_UID
    )(req, res, next);
    expect(NEXT_MOCK).not.toHaveBeenCalled();
    expect(RES_MOCK.json).toHaveBeenCalledTimes(1);
    expect(RES_MOCK.json).toHaveBeenCalledWith(DEFAULT_ERROR);
  });
});
