const Exception = require('../../src/error-handling/Exception');
const logger = require('../../src/logging/logService');
const helperMethods = require('../../src/helper-utils/helper-methods');


describe('src/helper-utils/helper-methods', () => {

  describe('repoErrorHandler', () => {
    test('should be able to replace message with error.error', () => {
      const err = {
        error: {
          error: 'mockError'
        },
        message: 'mockMessage',
        statusCode: 'mockStatusCode'
      };
      try {
        helperMethods.repoErrorHandler(err, logger, Exception);
      } catch (Exception) {
        expect(Exception.message).toBe('Exception is not a constructor');
      }
    });
  });

  describe('isValidSubArray', () => {
    test('should return false if not a sub array', () => {
      const array = [1, 2, 3, 4, 5];
      const subarry = 6;
      expect(helperMethods.isValidSubArray(array, subarry)).toEqual(false);
    });
  });

  describe('removePropertyFromObj', () => {
    test('should be able to remove a property from an object', () => {
      const obj = {
        requester: 'test',
        property1: 'property1',
        property2: 'property2'
      };
      helperMethods.removePropertyFromObj(obj, 'requester');
      expect(obj).toEqual({
        property1: 'property1',
        property2: 'property2'
      });
    });
  });

  describe('isObjFieldChanged', () => {
    test('should return false if newObj is null', () => {
      expect(helperMethods.isObjFieldChanged(null, {})).toBe(false);
    });

    test('should return true if object field gets changed', () => {
      const obj1 = {
        a: [{
          b: 1
        }]
      },
        obj2 = {
          a: [{
            b: 2
          }]
        };

      expect(helperMethods.isObjFieldChanged(obj1, obj2)).toBe(true);
    });
  });

  describe('isNestedObjChanged', () => {
    test('should return false if newObj is null', () => {
      expect(helperMethods.isNestedObjChanged(null, {})).toBe(false);
    });
    test('should return true if object field gets changed', () => {
      const obj1 = {
        a: {
          b: 1
        }
      },
        obj2 = {
          a: [{
            b: 2
          }]
        };

      expect(helperMethods.isNestedObjChanged(obj1, obj2)).toBe(true);
    });
  });

  describe('isEmptyObject', () => {
    test('should return true if object is empty', () => {
      expect(helperMethods.isEmptyObject({})).toBe(true);
    });

    test('should return false if object is not empty', () => {
      expect(helperMethods.isEmptyObject({
        a: 'string'
      })).toBe(false);
    });
  });

  describe('arrayDiff', () => {
    test('should return false if the params are not array', () => {
      expect(helperMethods.arrayDiff('string1', 'string2')).toBe(false);
    });
  });

  describe('isValidString', () => {
    test('should return true if it is a valid string', () => {
      expect(helperMethods.isValidString('s')).toBe(true);
    });

    test('should return false if it is an empty string', () => {
      expect(helperMethods.isValidString(' ')).toBe(false);
    });

    test('should return false if it is a number', () => {
      expect(helperMethods.isValidString(1)).toBe(false);
    });
  });

  describe('buildRemoveExpression', () => {
    test('return empty string if param is empty', () => {
      expect(helperMethods.buildRemoveExpression()).toEqual('');
    });
    test('return empty string if param is empty array', () => {
      expect(helperMethods.buildRemoveExpression([])).toEqual('');
    });
    test('if array is longer than 2', () => {
      expect(helperMethods.buildRemoveExpression(['field1, field2, field3'])).toEqual('REMOVE field1, field2, field3');
    });
  });

  describe('removeDuplicates', () => {
    test('should remove valid duplicate id ', () => {
      expect(helperMethods.removeDuplicates(['13c62ce4-2d08-4ef0-adf9-ff7a96165dc0',
        'ada7a6d7-885c-41d6-8c45-b917956bca78d', '13c62ce4-2d08-4ef0-adf9-ff7a96165dc0']))
        .toStrictEqual(["13c62ce4-2d08-4ef0-adf9-ff7a96165dc0", "ada7a6d7-885c-41d6-8c45-b917956bca78d"]);
    });

    test('should remove if multiple duplicate id is found', () => {
      expect(helperMethods.removeDuplicates(['12-12-WWW', 'ada7a6d7', '777', '13c62ce4', '777', '13c62ce4', '12-12-WWW']))
        .toStrictEqual(["12-12-WWW", "ada7a6d7", "777", "13c62ce4"]);
    });

    test('should remove undefined value is found in array ', () => {
      expect(helperMethods.removeDuplicates([' ', , 'WWW', ' ']))
        .toStrictEqual(["WWW"]);
    });
  });

  describe('transformData', () => {
    test('should be able to remove white spaces from request body', () => {
      const req = {
        body: {
          error: 'mockError   '
        },
        message: '     mockMessage      ',
        statusCode: 'mockStatusCode    '
      };
      expect(helperMethods.transformData(req)).toEqual();
    });
  });

  describe('isNonEmptyObject', () => {
    test('should return false if not a valid hailer id', () => {
      const obj = 123;
      expect(helperMethods.isNonEmptyObject(obj)).toEqual(false);
    });
  });

  describe('isNonNegativeInteger', () => {
    test('should return true if Input value is a positive Integer ', () => {
      const value = 123;
      expect(helperMethods.isNonNegativeInteger(value)).toEqual(true);
    });
  });

  describe('isValFieldChanged', () => {
    test('should return true if newVal is different from oldVal ', () => {
      const newVal = 123
      const oldVal = 321
      expect(helperMethods.isValFieldChanged(newVal, oldVal)).toEqual(true);
    });
  });

});
