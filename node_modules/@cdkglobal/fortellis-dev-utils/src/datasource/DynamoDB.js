const {
  logService: logger,
  errorHandling: { Exception }
} = require('../index');
const aws = require('aws-sdk');

// Errors as defined here: https://confluence.cdk.com/display/CE/DynamoDB+Error+Handling+Guidance
const AWS_ERROR_CODES = {
  AccessDeniedException: 'internalerror',
  ConditionalCheckFailedException: 'internalerror',
  IncompleteSignatureException: 'internalerror',
  ItemCollectionSizeLimitExceededException: 'internalerror',
  MissingAuthenticationTokenException: 'internalerror',
  LimitExceededException: 'internalerror',
  ResourceInUseException: 'internalerror',
  ResourceNotFoundException: 'internalerror',
  ThrottlingException: 'internalerror',
  RequestLimitExceeded: 'internalerror',
  UnrecognizedClientException: 'internalerror',
  ValidationException: 'internalerror',
  ProvisionedThroughputExceededException: 'throttle'
};
const ERROR_RESPONSES = {
  internalerror: {
    httpCode: 500,
    message: 'Internal Server Error.'
  },
  throttle: {
    httpCode: 429,
    message: 'Too Many Requests.'
  },
  unavaliable: {
    httpCode: 503,
    message: 'Service Unavaliable. Please Retry.'
  }
};

class Dynamo {
  constructor({ maxRetries = 3 } = {}) {
    const dynamoService = new aws.DynamoDB({ maxRetries });
    this.docClient = new aws.DynamoDB.DocumentClient({
      service: dynamoService
    });
  }

  handleResponse(context) {
    return res => {
      logger.info({
        message: 'Dynamo transaction succeeded',
        operation: context
      });
      return res;
    };
  }

  handleError(params, context) {
    return err => {
      const { code, statusCode } = err;

      logger.error({
        message: 'Dynamo transaction failed',
        operation: context,
        dynamoError: err,
        params
      });

      if (statusCode === 400) {
        const errorType = code ? AWS_ERROR_CODES[code] : undefined;
        if (errorType) {
          throw { ...ERROR_RESPONSES[errorType], code };
        }
      }

      if (statusCode === 500 || statusCode === 503) {
        throw { ...ERROR_RESPONSES.unavaliable, code };
      }

      // Default case, throw internal server error
      throw { ...ERROR_RESPONSES.internalerror, code };
    };
  }

  scan(params = {}) {
    const op = 'scan';

    if (!params.TableName) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .scan(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  query(params = {}) {
    const op = 'query';

    if (!params.TableName) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .query(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  get(params = {}) {
    const op = 'get';

    if (!params.TableName) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .get(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  put(params = {}) {
    const op = 'put';

    if (!params.TableName || !params.Item) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .put(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  batchWrite(params = {}) {
    const op = 'batchWrite';

    if (Object.keys(params.RequestItems).length === 0) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .batchWrite(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  batchGet(params = {}) {
    const op = 'batchGet';

    if (Object.keys(params.RequestItems).length === 0) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .batchGet(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  update(params = {}) {
    const op = 'update';

    if (!params.TableName || !params.Key) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .update(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  delete(params = {}) {
    const op = 'delete';

    if (!params.TableName || !params.Key) {
      throw new Exception({
        message: 'Bad Input',
        function: op,
        arguments: params
      });
    }

    return this.docClient
      .delete(params)
      .promise()
      .then(this.handleResponse(op))
      .catch(this.handleError(params, op));
  }

  /**
   * The below methods should be considered deprecated and are remaining
   * for backwards compatibility with services that are still using the
   * "re-named" dynamo functions.
   *
   * They have been replaced by the methods above that match the given
   * DynamoDB methods provided by DocumentClient.
   */

  result(params, resolve, reject, context = 'unknown') {
    return (err, data) => {
      if (err) {
        logger.info({
          message: 'Dynamo transaction failed',
          error: err,
          params,
          operation: context
        });
        reject(err);
      } else {
        logger.info({
          message: 'Dynamo transaction succeeded',
          operation: context
        });
        // Resolving with full response from dynamo
        resolve(data);
      }
    };
  }

  addItem(params = {}) {
    const { TableName, Item } = params;
    if (!(TableName && Item))
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.addItem',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'put';
      this.docClient.put(params, this.result(params, resolve, reject, op));
    });
  }

  getItems(params = {}) {
    const { TableName } = params;
    if (!TableName)
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.getItems',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'scan';
      this.docClient.scan(params, this.result(params, resolve, reject, op));
    });
  }

  queryItems(params = {}) {
    const { TableName } = params;
    if (!TableName)
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.queryItems',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'query';
      this.docClient.query(params, this.result(params, resolve, reject, op));
    });
  }

  getItem(params = {}) {
    const { TableName } = params;
    if (!TableName)
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.getItem',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'get';
      this.docClient.get(params, this.result(params, resolve, reject, op));
    });
  }

  updateItem(params = {}) {
    const { TableName, Key } = params;
    if (!(TableName && Key))
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.updateItem',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'update';
      this.docClient.update(params, this.result(params, resolve, reject, op));
    });
  }

  deleteItem(params = {}) {
    const { TableName, Key } = params;
    if (!(TableName && Key))
      throw new Exception({
        message: 'Bad Input',
        function: 'DynamoDBRepo.deleteItem',
        arguments: params
      });

    return new Promise((resolve, reject) => {
      const op = 'delete';
      this.docClient.delete(params, this.result(params, resolve, reject, op));
    });
  }
}

module.exports = new Dynamo();
