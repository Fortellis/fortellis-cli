'use strict';

const assert = require('assert');

function repoErrorHandler(err, logger, Exception) {
  const {
    error,
    statusCode
  } = err;
  const message = (isValidObject(error) && error.hasOwnProperty('error')) ? error.error : err.message;
  logger.error({
    error,
    message,
    statusCode
  });
  throw new Exception({
    error,
    message,
    statusCode
  });
}

function isValidObject(obj) {
  return obj !== null && typeof obj === 'object' && obj.constructor.toString().indexOf("Object") !== -1;
}

function isEmptyObject(obj) {
  return isValidObject(obj) && Object.keys(obj).length === 0;
}

function isNonEmptyObject(obj) {
  return isValidObject(obj) && Object.keys(obj).length > 0;
}

function transformData(data) {
  Object.keys(data).forEach(key => {
    let value = data[key];
    if (typeof value === 'string') {
      data[key] = value.trim();
    }
    if (isValidObject(value)) {
      Object.keys(value).forEach(subKey => {
        let subValue = value[subKey];
        if (typeof subValue === 'string') {
          data[key][subKey] = subValue.trim();
        }
      });
    }
  });
}

function arrayDiff(super_array, sub_array) {
  if (!Array.isArray(super_array) || !Array.isArray(sub_array)) {
    return false;
  }
  return super_array.filter(x => !sub_array.includes(x));
}

function isNonNegativeInteger(value) {
  return Number.isInteger(value) && value >= 0;
}

function isValidSubArray(super_array, sub_array) {
  if (!Array.isArray(super_array) || !Array.isArray(sub_array)) {
    return false;
  }
  return sub_array.every(value => (super_array.indexOf(value) >= 0));
}

function isValFieldChanged(newVal, oldVal) {
  return newVal && newVal !== oldVal;
}

function isObjFieldChanged(newObj, oldObj) {
  if (!newObj) {
    return false;
  }
  let isChanged = false;

  if (newObj.enabled !== oldObj.enabled) {
    isChanged = true;
  } else {
    isChanged = shallowCompareObj(newObj, oldObj);
  }
  return isChanged;
}

function isNestedObjChanged(newObj, oldObj) {
  if (!newObj) {
    return false;
  }
  try {
    assert.deepStrictEqual(newObj, oldObj);
  } catch (e) {
    return true;
  }
  return false;
}

function shallowCompareObj(newObj, oldObj) {
  let isChanged = false;
  Object.keys(newObj).forEach(key => {
    if (Array.isArray(newObj[key])) {
      if (JSON.stringify(newObj[key].sort()) !== JSON.stringify(oldObj[key].sort())) {
        isChanged = true;
      }
    } else {
      if (newObj[key] !== oldObj[key]) {
        isChanged = true;
      }
    }
  });
  return isChanged;
}

function removePropertyFromObj(obj, property) {
  if (isValidObject(obj) && obj.hasOwnProperty(property)) {
    delete obj[property];
  }
}

function isValidString(stringVal) {
  return typeof stringVal === 'string' && stringVal.trim().length > 0;
}

function buildRemoveExpression(paths) {
  if (!paths || paths.length === 0) {
    return '';
  }
  let updateExpression = 'REMOVE ';
  updateExpression += paths.join(', ');
  return updateExpression;
}

function removeDuplicates(inputArr) {
  let length = inputArr.length, result = [], seen = new Set();
  for (let index = 0; index < length; index++) {
    let value = inputArr[index];
    if (!value || value.trim() == "") continue;
    value = value.trim();
    if (seen.has(value.trim())) continue;
    seen.add(value);
    result.push(value);
  }
  return result;
}

module.exports = {
  removePropertyFromObj: removePropertyFromObj,
  repoErrorHandler: repoErrorHandler,
  isValidObject: isValidObject,
  isEmptyObject: isEmptyObject,
  isNonEmptyObject: isNonEmptyObject,
  transformData: transformData,
  arrayDiff: arrayDiff,
  isValidSubArray: isValidSubArray,
  isValFieldChanged: isValFieldChanged,
  isObjFieldChanged: isObjFieldChanged,
  isNestedObjChanged: isNestedObjChanged,
  shallowCompareObj: shallowCompareObj,
  isValidString: isValidString,
  buildRemoveExpression: buildRemoveExpression,
  isNonNegativeInteger: isNonNegativeInteger,
  removeDuplicates: removeDuplicates
};
