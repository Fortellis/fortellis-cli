const { logService: logger } = require('../index');
// Constants
const ADMIN_ENTITY = '*';
const messages = {
  DEFAULT: 'You do not have permission to perform actions on this resource.',
  MISSING_ENTITLEMENT:
    'You do not have the valid entitlements to access this resource.',
  WRONG_ENTITY:
    'You do not have permissions to perform actions on this entity.',
  WRONG_DEVELOPER:
    'You do not have permissions to perform actions on this developer.',
  WRONG_USER:
    'You do not have permissions to perform actions on this resource.',
  ERROR: 'Failed to check user entitlements',
  ENTITY_NOT_FOUND: 'entityId not present in token',
  USERNAME_NOT_FOUND: 'username not present in token',
  USER_NOT_FOUND: 'uid not present in token'
};

/*
 * Entitlements Middleware for processing required permissions to access an endpoint
 * @param {object} permission - Object containing the resource and action required
 * @param {function} findEntityContext - function used to find the current entity being acted upon, expected to be a unary function that accepts a Node request object
 * @param {function} findUserContext - function used to find the current user being acted upon, expected to be a unary function that accepts a Node request object
 * @returns {function} Express middleware function
 */
function entitlementsProcessor(
  permission,
  findEntityContext,
  findUsername,
  findUid
) {
  return async function(req, res, next) {
    const {
      apiGateway: {
        event: {
          requestContext: {
            authorizer: {
              uid: userUid,
              entitlements,
              entityId: userEntity,
              username: userDeveloperId
            }
          }
        }
      }
    } = req;

    try {
      // Handle default case with permission provided
      if (permission) {
        if (!findEntityContext) {
          return deny(res, {
            uid: userUid,
            entityId: userEntity,
            message: messages.ENTITY_NOT_FOUND
          });
        }

        const entityId = findEntityContext(req);
        if (!entityId) {
          return deny(res, {
            uid: userUid,
            entityId: userEntity,
            message: messages.ENTITY_NOT_FOUND
          });
        }

        const userEntitlements = parseEntitlements(entitlements);
        const isAdmin = Object.keys(userEntitlements).includes(ADMIN_ENTITY);
        if (entityId !== userEntity && !isAdmin) {
          return deny(res, {
            uid: userUid,
            entityId: userEntity,
            message: messages.WRONG_ENTITY
          });
        }

        const avaliableEntitlements = filterEntitlements(
          userEntitlements,
          entityId
        );
        // Check the user has the correct entitlements
        const hasEntitlement = checkEntitlements(
          permission,
          avaliableEntitlements
        );
        if (!hasEntitlement) {
          return deny(res, {
            uid: userUid,
            entityId: userEntity,
            message: messages.MISSING_ENTITLEMENT
          });
        }
        return next();
      }

      // Handle non-entitlement related ownership
      if (!findEntityContext && !findUsername && !findUid) {
        return next();
      }

      let allow = false;

      if (findEntityContext) {
        const entityId = await findEntityContext(req);
        if (entityId && entityId === userEntity) {
          allow = true;
        }
      }

      if (findUsername) {
        const username = await findUsername(req);
        if (username && username === userDeveloperId) {
          allow = true;
        }
      }

      if (findUid) {
        const uid = await findUid(req);
        if (uid && uid == userUid) {
          allow = true;
        }
      }

      if (allow) {
        return next();
      }

      return deny(res, {
        uid: userUid,
        entityId: userEntity,
        message: messages.DEFAULT
      });
    } catch (err) {
      logger.info({
        uid: userUid,
        permission,
        message: err.message || messages.ERROR
      });
      res.status(500);
      return res.json(messages.ERROR);
    }
  };
}

function safeParse(src) {
  if (typeof src === 'object') {
    return src;
  }
  return JSON.parse(src);
}

// Double parse the strigified entitlements
function parseEntitlements(entitlements) {
  if (!entitlements) return {};
  const userEntitlements = safeParse(entitlements);
  for (let resource of Object.keys(userEntitlements)) {
    userEntitlements[resource] = safeParse(userEntitlements[resource]);
  }
  return userEntitlements;
}

function filterEntitlements(entitlements, entityId) {
  return Object.entries(entitlements).map(([key, value]) => {
    if (key === entityId || key === ADMIN_ENTITY) {
      return value;
    }
  });
}

// Compare entitlements with the required permission and return true/false
function checkEntitlements(permission, entitlements) {
  return entitlements.some(entitlement => {
    if (!entitlement) return false;
    const resource = entitlement[permission.resource];
    if (!resource) return false;
    return resource.includes(permission.action);
  });
}

// If the user does not have correct entitlements, send back a 403 and log
function deny(res, context) {
  logger.info(context);
  res.status(403);
  return res.json(context.message || messages.DEFAULT);
}

module.exports = entitlementsProcessor;
