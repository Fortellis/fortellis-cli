'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _util = require('util');

var _gpxParse = require('gpx-parse');

var _gpxParse2 = _interopRequireDefault(_gpxParse);

var _rx = require('rx');

var _nodeGeoDistance = require('node-geo-distance');

var _nodeGeoDistance2 = _interopRequireDefault(_nodeGeoDistance);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VELOCITY_THRESHOLD = 0.5;

var pointDecorationFn = function pointDecorationFn(d) {
  return {
    lat: d.latlng[0],
    lon: d.latlng[1],
    elapsedTime: d.elapsedTime
  };
};

var Stoplight = function () {
  function Stoplight() {
    _classCallCheck(this, Stoplight);
  }

  _createClass(Stoplight, [{
    key: 'stopsFromGpx',
    value: function stopsFromGpx(path) {
      var parseGpx = _rx.Observable.fromNodeCallback(_gpxParse2.default.parseGpxFromFile);
      var fileStream = parseGpx(path);
      var pointStream = fileStream.flatMap(function (res) {
        return res.tracks;
      }).flatMap(function (trk) {
        return trk.segments;
      }).flatMap(function (segment) {
        return segment;
      });

      var pairIntervalStream = pointStream.pairwise();

      var combinedStatStream = pairIntervalStream.map(function (pairs) {
        var _pairs = _slicedToArray(pairs, 2);

        var p1 = _pairs[0];
        var p2 = _pairs[1];


        var dist = _nodeGeoDistance2.default.haversineSync({ latitude: p1.lat, longitude: p1.lon }, { latitude: p2.lat, longitude: p2.lon });
        var t1 = Date.parse(p1.time);
        var t2 = Date.parse(p2.time);
        var delta = t2 - t1;
        var seconds = delta / 1000;

        return {
          velocity: dist / seconds,
          lat: p2.lat,
          lon: p2.lon,
          elapsedTime: seconds
        };
      });

      var stopStream = combinedStatStream.filter(function (d) {
        return d.velocity < VELOCITY_THRESHOLD;
      });
      return stopStream.reduce(function (acc, evt) {
        return acc.concat(evt);
      }, []).toPromise(_bluebird2.default);
    }
  }, {
    key: 'stopsFromZippedStravaStream',
    value: function stopsFromZippedStravaStream(input) {
      return _rx.Observable.from(input).pairwise().map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var p1 = _ref2[0];
        var p2 = _ref2[1];

        var elapsedTime = p2.time - p1.time;
        var velocity = (p2.distance - p1.distance) / elapsedTime;
        return Object.assign({}, p2, { velocity: velocity, elapsedTime: elapsedTime });
      })
      // Decorate with an index counter
      .scan(function (acc, point) {
        return Object.assign({}, point, {
          index: acc.index + 1
        });
      }, { index: 0 }).filter(function (v) {
        return v.velocity < VELOCITY_THRESHOLD;
      })
      // Coalesce points together based on whether you are a part
      // of an increasing series of start indices.
      // Now mark which startingIndex you are a part of
      .scan(function (acc, current) {
        var startingIndex = undefined;
        // If part of a matching contiguous group.
        if (current.index == acc.lastIndex + 1) {
          startingIndex = acc.startingIndex;
        } else {
          // Start the starting index at the current point
          startingIndex = current.index;
        }
        return Object.assign({}, current, {
          startingIndex: startingIndex,
          lastIndex: current.index
        });
      }, { startingIndex: 0, lastIndex: 0 })
      // For some reason, the scan() above emits the default value without any prior values on the stream.
      // Filter only for "real" values.
      .filter(function (v) {
        return !isNaN(v.elapsedTime);
      }).groupBy(function (p) {
        return p.startingIndex;
      }).flatMap(function (g) {
        return g.reduce(function (past, current) {
          return Object.assign({}, current, { elapsedTime: past.elapsedTime + current.elapsedTime });
        }, { elapsedTime: 0 });
      }).map(pointDecorationFn).toArray().toPromise(_bluebird2.default);
    }
  }]);

  return Stoplight;
}();

exports.default = Stoplight;